/**
 * =============================================================================
 * Homura - Core Type Definitions
 * =============================================================================
 * 
 * This file defines the fundamental data structures for the Homura automation
 * engine. The architecture follows a "LEGO Pattern" where:
 * 
 * 1. Primitives: Hardcoded atomic actions (cannot be modified by AI)
 * 2. Atomic Tools: JSON configurations that combine primitives (generated by AI)
 * 3. Selector Logic: Scope + Anchor + Target pattern for robust element selection
 */

// =============================================================================
// PRIMITIVES - The building blocks (硬编码的基础动作)
// =============================================================================

/**
 * Primitive action types - these are the only allowed actions.
 * AI cannot invent new action types; it can only use these.
 */
export type PrimitiveAction = 
  | 'CLICK'         // Click on an element
  | 'INPUT'         // Input text into a field
  | 'EXTRACT_TEXT'  // Extract text content from element(s)
  | 'WAIT_FOR'      // Wait for an element to appear
  | 'NAVIGATE';     // Navigate to a URL

/**
 * Action-specific parameters for each primitive
 */
export interface ClickParams {
  /** Whether to use debug mode (Chrome DevTools Protocol) for bot detection bypass */
  debugMode?: boolean;
}

export interface InputParams {
  /** The value to input */
  value: string;
  /** Whether to clear existing content first */
  clearFirst?: boolean;
  /** Delay between keystrokes (ms) for realistic typing */
  typeDelay?: number;
}

export interface ExtractTextParams {
  /** Whether to extract from multiple elements */
  multiple?: boolean;
  /** Attribute to extract instead of textContent */
  attribute?: string;
}

export interface WaitForParams {
  /** Timeout in milliseconds */
  timeout?: number;
  /** Wait for element to be visible (not just in DOM) */
  visible?: boolean;
}

export interface NavigateParams {
  /** URL to navigate to */
  url: string;
  /** Whether to wait for page load to complete */
  waitForLoad?: boolean;
}

// =============================================================================
// SELECTOR LOGIC - Scope + Anchor + Target Pattern
// =============================================================================

/**
 * Scope: Defines the container/list to search within
 * Example: Find all table rows (tr.audit-row)
 */
export interface SelectorScope {
  /** Type of scope */
  type: 'container_list' | 'single_container';
  /** CSS selector for the scope */
  selector: string;
}

/**
 * Anchor: Defines how to locate a specific item within the scope
 * Example: Find the row where .student-name contains "张三"
 */
export interface SelectorAnchor {
  /** Type of anchor matching */
  type: 'text_match' | 'attribute_match' | 'index';
  /** CSS selector within the scope to check */
  selector: string;
  /** Value to match against (supports {{variable}} syntax) */
  value: string;
  /** For attribute_match: which attribute to check */
  attribute?: string;
  /** Match mode: exact, contains, startsWith, endsWith */
  matchMode?: 'exact' | 'contains' | 'startsWith' | 'endsWith';
}

/**
 * Target: The actual element to operate on
 * Example: Click the button.btn-approve within the matched row
 */
export interface SelectorTarget {
  /** CSS selector for the target element (relative to scope/anchor) */
  selector: string;
  /** Action to perform */
  action: PrimitiveAction;
  /** Action-specific parameters */
  actionParams?: ClickParams | InputParams | ExtractTextParams | WaitForParams | NavigateParams;
}

/**
 * Complete selector logic combining Scope + Anchor + Target
 * 
 * Flow:
 * 1. If scope is defined: Find all matching container elements
 * 2. If anchor is defined: Filter containers to find the matching one
 * 3. Within the matched container (or document if no scope): Find and operate on target
 */
export interface SelectorLogic {
  /** Optional: Container scope to search within */
  scope?: SelectorScope;
  /** Optional: Anchor to locate specific container within scope */
  anchor?: SelectorAnchor;
  /** Required: Target element and action */
  target: SelectorTarget;
}

// =============================================================================
// ATOMIC TOOL - The JSON structure AI generates
// =============================================================================

/**
 * Parameter definition for an atomic tool
 */
export interface ToolParameter {
  type: 'string' | 'number' | 'boolean' | 'array';
  description: string;
  required?: boolean;
  default?: string | number | boolean;
}

/**
 * Atomic Tool: A complete, reusable automation action
 * 
 * This is what AI generates from user recordings or natural language.
 * It combines primitives according to the selector logic.
 */
export interface AtomicTool {
  /** Unique identifier */
  tool_id: string;
  /** Human-readable name */
  name: string;
  /** Description of what this tool does */
  description?: string;
  /** Parameter definitions (for variable substitution) */
  parameters: Record<string, ToolParameter>;
  /** The selection and action logic */
  selector_logic: SelectorLogic;
}

// =============================================================================
// EXECUTION TYPES - Request/Response for tool execution
// =============================================================================

/**
 * Request to execute an atomic tool
 */
export interface ExecuteToolRequest {
  /** The tool definition */
  tool: AtomicTool;
  /** Parameter values to substitute */
  params: Record<string, string | number | boolean>;
  /** Enable debug mode (show highlights, slow execution) */
  debug?: boolean;
}

/**
 * Result of tool execution
 */
export interface ExecuteToolResult {
  /** Whether execution was successful */
  success: boolean;
  /** Extracted data (for EXTRACT_TEXT action) */
  data?: string | string[];
  /** Error message if failed */
  error?: ExecutionError;
  /** Execution metadata */
  metadata?: {
    /** Time taken in milliseconds */
    duration: number;
    /** Number of elements matched by scope */
    scopeMatchCount?: number;
    /** Index of anchor-matched element */
    anchorMatchIndex?: number;
  };
}

/**
 * Structured error for self-healing agent
 */
export interface ExecutionError {
  /** Error code for programmatic handling */
  code: 
    | 'SCOPE_NOT_FOUND'      // Scope selector matched 0 elements
    | 'ANCHOR_NOT_FOUND'     // No element in scope matched anchor
    | 'TARGET_NOT_FOUND'     // Target selector not found in context
    | 'ACTION_FAILED'        // Action execution failed
    | 'TIMEOUT'              // Wait timeout exceeded
    | 'INVALID_SELECTOR'     // CSS selector syntax error
    | 'UNKNOWN';             // Unexpected error
  /** Human-readable message */
  message: string;
  /** The selector that failed (for self-healing) */
  failedSelector?: string;
  /** Snapshot of nearby DOM for AI analysis */
  domSnapshot?: string;
}

// =============================================================================
// MESSAGING TYPES - Communication between Background and Content Script
// =============================================================================

/**
 * Message types for Background <-> Content Script communication
 */
export type MessageType = 
  | 'EXECUTE_TOOL'           // Background -> Content: Execute a tool
  | 'EXECUTION_RESULT'       // Content -> Background: Return result
  | 'HIGHLIGHT_ELEMENT'      // Background -> Content: Highlight for debug
  | 'CLEAR_HIGHLIGHTS'       // Background -> Content: Clear debug highlights
  | 'GET_PAGE_STATE'         // Background -> Content: Get DOM summary
  | 'PAGE_STATE';            // Content -> Background: DOM summary response

/**
 * Base message structure
 */
export interface Message<T extends MessageType, P = unknown> {
  type: T;
  payload: P;
  /** Unique message ID for request-response matching */
  messageId?: string;
}

// Specific message types
export type ExecuteToolMessage = Message<'EXECUTE_TOOL', ExecuteToolRequest>;
export type ExecutionResultMessage = Message<'EXECUTION_RESULT', ExecuteToolResult>;
export type HighlightElementMessage = Message<'HIGHLIGHT_ELEMENT', { selector: string; color?: string }>;
export type ClearHighlightsMessage = Message<'CLEAR_HIGHLIGHTS', undefined>;

// Union of all message types
export type HomuraMessage = 
  | ExecuteToolMessage 
  | ExecutionResultMessage 
  | HighlightElementMessage
  | ClearHighlightsMessage;

// =============================================================================
// MISSION & RULE BOOK TYPES (for future AI integration)
// =============================================================================

/**
 * A Mission represents a complete automation task
 */
export interface Mission {
  id: string;
  name: string;
  description?: string;
  /** Rule book in markdown format */
  ruleBook: string;
  /** Tools available for this mission */
  toolIds: string[];
  /** Current status */
  status: 'idle' | 'running' | 'paused' | 'completed' | 'error';
}

/**
 * Execution log entry
 */
export interface LogEntry {
  timestamp: number;
  level: 'info' | 'warn' | 'error' | 'debug';
  message: string;
  toolId?: string;
  data?: unknown;
}
